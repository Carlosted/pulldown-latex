//! A module that implements the behavior of every primitive of the supported LaTeX syntax. This
//! includes every primitive macro and active character.

use core::panic;

use crate::{
    attribute::{DimensionUnit, Font},
    event::{
       ColorChange as CC, ColorTarget as CT, Content as C, DelimiterSize, DelimiterType, Event as E, Grouping as G, ScriptPosition as SP, ScriptType as ST, StateChange as SC, Style as S, Visual as V, ArrayColumn as AC
    },
};

use super::{
    lex, tables::{char_delimiter_map, control_sequence_delimiter_map, is_binary, is_primitive_color, is_relation, token_to_delim}, Argument, CharToken, ErrorKind, InnerParser, InnerResult, Instruction as I, Token
};

impl<'a, 'b> InnerParser<'a, 'b> {
    /// Handle a character token, returning a corresponding event.
    ///
    /// This function specially treats numbers as `mi`.
    ///
    /// ## Panics
    /// - This function will panic if the `\` or `%` character is given
    pub(super) fn handle_char_token(&mut self, token: CharToken<'a>) -> InnerResult<()> {
        let instruction = I::Event(match token.into() {
            '\\' => panic!("(internal error: please report) the `\\` character should never be observed as a token"),
            '%' => panic!("(internal error: please report) the `%` character should never be observed as a token"),
            '_' => {
                self.buffer.extend([
                    I::Event(E::Begin(G::Normal)),
                ]);
                self.content = token.as_str();
                E::End
            }
            '^' => {
                self.buffer.extend([
                    I::Event(E::Begin(G::Normal)),
                ]);
                self.content = token.as_str();
                E::End
            }
            '$' => return Err(ErrorKind::MathShift),
            '#' => return Err(ErrorKind::HashSign),
            '&' if self.state.allows_alignment => E::Alignment,
            '{' => {
                let str = &mut self.content;
                let group = lex::group_content(str, "{", "}")?;
                self.buffer.extend([
                    I::Event(E::Begin(G::Normal)),
                    I::SubGroup { content: group, allows_alignment: false },
                    I::Event(E::End)
                ]);
                return Ok(())
            },
            '}' => {
                return Err(ErrorKind::UnbalancedGroup(None))
            },

            // Special ( ~ = nobreak space)
            // TODO: Make this a `Spacing` event
            '~' => {
                E::Content(C::Text("&nbsp;"))
            },

            '0'..='9' => {
                let content = token.as_str();
                let mut len = content
                    .chars()
                    .skip(1)
                    .take_while(|&c| matches!(c, '.' | ',' | '0'..='9'))
                    .count()
                    + 1;
                if matches!(content.as_bytes()[len - 1], b'.' | b',') {
                    len -= 1;
                }
                let (number, rest) = content.split_at(len);
                self.content = rest;
                self.buffer
                    .push(I::Event(E::Content(C::Number(number))));
                return Ok(())
            }
            // Punctuation
            '.' | ',' | ';' => E::Content(C::Punctuation(token.into())),
            
            '\'' => ordinary('‚Ä≤'),
            '-' => binary('‚àí'),
            '*' => binary('‚àó'),
            
            c if is_binary(c) => binary(c),
            c if is_relation(c) => relation(c),
                

            c if char_delimiter_map(c).is_some() => {
                let (content, ty) = char_delimiter_map(c).unwrap();
                if ty == DelimiterType::Fence {
                    ordinary(content)
                } else {
                E::Content(C::Delimiter {
                    content,
                    size: None,
                    ty,
                })
                }
            }
            
            c => ordinary(c),
        });
        self.buffer.push(instruction);
        Ok(())
    }

    /// Handle a supported control sequence, pushing instructions to the provided stack.
    pub(super) fn handle_primitive(&mut self, control_sequence: &'a str) -> InnerResult<()> {
        let event = match control_sequence {
            "arccos" | "cos" | "csc" | "exp" | "ker" | "sinh" | "arcsin" | "cosh" | "deg"
            | "lg" | "ln" | "arctan" | "cot" | "det" | "hom" | "log" | "sec" | "tan" | "arg"
            | "coth" | "dim" | "sin" | "tanh" | "sgn" => {
                E::Content(C::Function(control_sequence))
            }
            "lim" | "Pr" | "sup" | "liminf" | "max" | "inf" | "gcd" | "limsup" | "min" => {
                self.state.allow_suffix_modifiers = true;
                self.state.above_below_suffix_default = true;
                E::Content(C::Function(control_sequence))
            }
            "operatorname" => {
                self.state.allow_suffix_modifiers = true;
                let argument = lex::argument(&mut self.content)?;
                match argument {
                    Argument::Token(Token::ControlSequence(_)) => {
                        return Err(ErrorKind::ControlSequenceAsArgument)
                    }
                    Argument::Token(Token::Character(char_)) => {
                        E::Content(C::Function(char_.as_str()))
                    }
                    Argument::Group(content) => {
                        E::Content(C::Function(content))
                    }
                }
            }
            "bmod" => E::Content(C::Function("mod")),
            // TODO: use left right.
            "pmod" => {
                let argument = lex::argument(&mut self.content)?;
                self.buffer.extend([
                    I::Event(E::Begin(G::Internal)),
                    I::Event(E::Content(C::Delimiter {
                        content: '(',
                        size: None,
                        ty: DelimiterType::Open
                    })),
                ]);
                self.handle_argument(argument)?;
                self.buffer.extend([
                    I::Event(E::Content(C::Delimiter {
                     content: ')',
                     size: None,
                     ty: DelimiterType::Close
                    })),   
                    I::Event(E::End),
                ]);
                return Ok(());
            }

            // TODO: Operators with '*', for operatorname* and friends

            /////////////////////////
            // Non-Latin Alphabets //
            /////////////////////////
            // Lowercase Greek letters
            "alpha" => ordinary('Œ±'),
            "beta" => ordinary('Œ≤'),
            "gamma" => ordinary('Œ≥'),
            "delta" => ordinary('Œ¥'),
            "epsilon" => ordinary('œµ'),
            "zeta" => ordinary('Œ∂'),
            "eta" => ordinary('Œ∑'),
            "theta" => ordinary('Œ∏'),
            "iota" => ordinary('Œπ'),
            "kappa" => ordinary('Œ∫'),
            "lambda" => ordinary('Œª'),
            "mu" => ordinary('¬µ'),
            "nu" => ordinary('ŒΩ'),
            "xi" => ordinary('Œæ'),
            "pi" => ordinary('œÄ'),
            "rho" => ordinary('œÅ'),
            "sigma" => ordinary('œÉ'),
            "tau" => ordinary('œÑ'),
            "upsilon" => ordinary('œÖ'),
            "phi" => ordinary('œÜ'),
            "chi" => ordinary('œá'),
            "psi" => ordinary('œà'),
            "omega" => ordinary('œâ'),
            "omicron" => ordinary('Œø'),
            // Uppercase Greek letters
            "Alpha" => ordinary('Œë'),
            "Beta" => ordinary('Œí'),
            "Gamma" => ordinary('Œì'),
            "Delta" => ordinary('Œî'),
            "Epsilon" => ordinary('Œï'),
            "Zeta" => ordinary('Œñ'),
            "Eta" => ordinary('Œó'),
            "Theta" => ordinary('Œò'),
            "Iota" => ordinary('Œô'),
            "Kappa" => ordinary('Œö'),
            "Lambda" => ordinary('Œõ'),
            "Mu" => ordinary('Œú'),
            "Nu" => ordinary('Œù'),
            "Xi" => ordinary('Œû'),
            "Pi" => ordinary('Œ†'),
            "Rho" => ordinary('Œ°'),
            "Sigma" => ordinary('Œ£'),
            "Tau" => ordinary('Œ§'),
            "Upsilon" => ordinary('Œ•'),
            "Phi" => ordinary('Œ¶'),
            "Chi" => ordinary('Œß'),
            "Psi" => ordinary('Œ®'),
            "Omega" => ordinary('Œ©'),
            "Omicron" => ordinary('Œü'),
            // Lowercase Greek Variants
            "varepsilon" => ordinary('Œµ'),
            "vartheta" => ordinary('œë'),
            "varkappa" => ordinary('œ∞'),
            "varrho" => ordinary('œ±'),
            "varsigma" => ordinary('œÇ'),
            "varpi" => ordinary('œñ'),
            "varphi" => ordinary('œï'),
            // Uppercase Greek Variants
            "varGamma" => ordinary('ùõ§'),
            "varDelta" => ordinary('ùõ•'),
            "varTheta" => ordinary('ùõ©'),
            "varLambda" => ordinary('ùõ¨'),
            "varXi" => ordinary('ùõØ'),
            "varPi" => ordinary('ùõ±'),
            "varSigma" => ordinary('ùõ¥'),
            "varUpsilon" => ordinary('ùõ∂'),
            "varPhi" => ordinary('ùõ∑'),
            "varPsi" => ordinary('ùõπ'),
            "varOmega" => ordinary('ùõ∫'),

            // Hebrew letters
            "aleph" => ordinary('‚Ñµ'),
            "beth" => ordinary('‚Ñ∂'),
            "gimel" => ordinary('‚Ñ∑'),
            "daleth" => ordinary('‚Ñ∏'),
            // Other symbols
            "digamma" => ordinary('œù'),
            "eth" => ordinary('√∞'),
            "ell" => ordinary('‚Ñì'),
            "nabla" => ordinary('‚àá'),
            "partial" => ordinary('‚àÇ'),
            "Finv" => ordinary('‚Ñ≤'),
            "Game" => ordinary('‚Ñ∑'),
            "hbar" | "hslash" => ordinary('‚Ñè'),
            "imath" => ordinary('ƒ±'),
            "jmath" => ordinary('»∑'),
            "Im" => ordinary('‚Ñë'),
            "Re" => ordinary('‚Ñú'),
            "wp" => ordinary('‚Ñò'),
            "Bbbk" => ordinary('ùïú'),
            "Angstrom" => ordinary('‚Ñ´'),
            "backepsilon" => ordinary('œ∂'),

            ///////////////////////////
            // Symbols & Punctuation //
            ///////////////////////////
            "dots" => if self.content.trim_start().starts_with(['.', ',']) {
                ordinary('‚Ä¶')
            } else {
                ordinary('‚ãØ')
            }
            "ldots" | "dotso" | "dotsc" => ordinary('‚Ä¶'),
            "cdots" | "dotsi" | "dotsm" | "dotsb" | "idotsin" => ordinary('‚ãØ'),
            "ddots" => ordinary('‚ã±'),
            "iddots" => ordinary('‚ã∞'),
            "vdots" => ordinary('‚ãÆ'),
            "mathellipsis" => ordinary('‚Ä¶'),
            "infty" => ordinary('‚àû'),
            "checkmark" => ordinary('‚úì'),
            "ballotx" => ordinary('‚úó'),
            "dagger" | "dag" => ordinary('‚Ä†'),
            "ddagger" | "ddag" => ordinary('‚Ä°'),
            "angle" => ordinary('‚à†'),
            "measuredangle" => ordinary('‚à°'),
            "lq" => ordinary('‚Äò'),
            "Box" => ordinary('‚ñ°'),
            "sphericalangle" => ordinary('‚à¢'),
            "square" => ordinary('‚ñ°'),
            "top" => ordinary('‚ä§'),
            "rq" => ordinary('‚Ä≤'),
            "blacksquare" => ordinary('‚ñ†'),
            "bot" => ordinary('‚ä•'),
            "triangledown" => ordinary('‚ñΩ'),
            "Bot" => ordinary('‚´´'),
            "triangleleft" => ordinary('‚óÉ'),
            "triangleright" => ordinary('‚ñπ'),
            "cent" => ordinary('¬¢'),
            "colon" | "ratio" | "vcentcolon" => ordinary(':'),
            "bigtriangledown" => ordinary('‚ñΩ'),
            "pounds" | "mathsterling" => ordinary('¬£'),
            "bigtriangleup" => ordinary('‚ñ≥'),
            "blacktriangle" => ordinary('‚ñ≤'),
            "blacktriangledown" => ordinary('‚ñº'),
            "yen" => ordinary('¬•'),
            "blacktriangleleft" => ordinary('‚óÄ'),
            "euro" => ordinary('‚Ç¨'),
            "blacktriangleright" => ordinary('‚ñ∂'),
            "Diamond" => ordinary('‚óä'),
            "degree" => ordinary('¬∞'),
            "lozenge" => ordinary('‚óä'),
            "blacklozenge" => ordinary('‚ß´'),
            "mho" => ordinary('‚Ñß'),
            "bigstar" => ordinary('‚òÖ'),
            "diagdown" => ordinary('‚ï≤'),
            "maltese" => ordinary('‚ú†'),
            "diagup" => ordinary('‚ï±'),
            "P" => ordinary('¬∂'),
            "clubsuit" => ordinary('‚ô£'),
            "varclubsuit" => ordinary('‚ôß'),
            "S" => ordinary('¬ß'),
            "diamondsuit" => ordinary('‚ô¢'),
            "vardiamondsuit" => ordinary('‚ô¶'),
            "copyright" => ordinary('¬©'),
            "heartsuit" => ordinary('‚ô°'),
            "varheartsuit" => ordinary('‚ô•'),
            "circledR" => ordinary('¬Æ'),
            "spadesuit" => ordinary('‚ô†'),
            "varspadesuit" => ordinary('‚ô§'),
            "circledS" => ordinary('‚ìà'),
            "female" => ordinary('‚ôÄ'),
            "male" => ordinary('‚ôÇ'),
            "astrosun" => ordinary('‚òâ'),
            "sun" => ordinary('‚òº'),
            "leftmoon" => ordinary('‚òæ'),
            "rightmoon" => ordinary('‚òΩ'),
            "smiley" => ordinary('‚ò∫'),
            "Earth" => ordinary('‚äï'),
            "flat" => ordinary('‚ô≠'),
            "standardstate" => ordinary('‚¶µ'),
            "natural" => ordinary('‚ôÆ'),
            "sharp" => ordinary('‚ôØ'),
            "permil" => ordinary('‚Ä∞'),
            "QED" => ordinary('‚àé'),
            "lightning" => ordinary('‚ÜØ'),
            "diameter" => ordinary('‚åÄ'),
            "leftouterjoin" => ordinary('‚üï'),
            "rightouterjoin" => ordinary('‚üñ'),
            "concavediamond" => ordinary('‚ü°'),
            "concavediamondtickleft" => ordinary('‚ü¢'),
            "concavediamondtickright" => ordinary('‚ü£'),
            "fullouterjoin" => ordinary('‚üó'),
            "triangle" | "vartriangle" => ordinary('‚ñ≥'),
            "whitesquaretickleft" => ordinary('‚ü§'),
            "whitesquaretickright" => ordinary('‚ü•'),


            ////////////////////////
            // Font state changes //
            ////////////////////////
            // LaTeX native absolute font changes (old behavior a.k.a NFSS 1)
            "bf" => self.font_change(Font::Bold),
            "cal" => self.font_change(Font::Script),
            "it" => self.font_change(Font::Italic),
            "rm" => self.font_change(Font::UpRight),
            "sf" => self.font_change(Font::SansSerif),
            "tt" => self.font_change(Font::Monospace),
            // amsfonts font changes (old behavior a.k.a NFSS 1)
            // unicode-math font changes (old behavior a.k.a NFSS 1)
            // changes, as described in https://mirror.csclub.uwaterloo.ca/CTAN/macros/unicodetex/latex/unicode-math/unicode-math.pdf
            // (section. 3.1)
            "mathbf" | "symbf" | "mathbfup" | "symbfup" | "boldsymbol" => {
                return self.font_group(Some(Font::Bold))
            }
            "mathcal" | "symcal" | "mathup" | "symup" => {
                return self.font_group(Some(Font::Script))
            }
            "mathit" | "symit" => return self.font_group(Some(Font::Italic)),
            "mathrm" | "symrm" => return self.font_group(Some(Font::UpRight)),
            "mathsf" | "symsf" | "mathsfup" | "symsfup" => {
                return self.font_group(Some(Font::SansSerif))
            }
            "mathtt" | "symtt" => return self.font_group(Some(Font::Monospace)),
            "mathbb" | "symbb" => return self.font_group(Some(Font::DoubleStruck)),
            "mathfrak" | "symfrak" => return self.font_group(Some(Font::Fraktur)),
            "mathbfcal" | "symbfcal" => return self.font_group(Some(Font::BoldScript)),
            "mathsfit" | "symsfit" => return self.font_group(Some(Font::SansSerifItalic)),
            "mathbfit" | "symbfit" => return self.font_group(Some(Font::BoldItalic)),
            "mathbffrak" | "symbffrak" => return self.font_group(Some(Font::BoldFraktur)),
            "mathbfsfup" | "symbfsfup" => return self.font_group(Some(Font::BoldSansSerif)),
            "mathbfsfit" | "symbfsfit" => return self.font_group(Some(Font::SansSerifBoldItalic)),
            "mathnormal" | "symnormal" => return self.font_group(None),

            ////////////////////////
            // Style state change //
            ////////////////////////
            "displaystyle" => self.style_change(S::Display),
            "textstyle" => self.style_change(S::Text),
            "scriptstyle" => self.style_change(S::Script),
            "scriptscriptstyle" => self.style_change(S::ScriptScript),

            ////////////////////////
            // Color state change //
            ////////////////////////
            "color" => {
                let Argument::Group(color) =
                    lex::argument(&mut self.content)?
                else {
                    return Err(ErrorKind::Argument);
                };
                self.state.skip_suffixes = true;
                
                if !is_primitive_color(color) {
                    return Err(ErrorKind::UnknownColor);
                }
                E::StateChange(SC::Color(CC {
                    color,
                    target: CT::Text,
                }))
            },
            "textcolor" => {
                let str = &mut self.content;
                let Argument::Group(color) =
                    lex::argument(str)?
                else {
                    return Err(ErrorKind::Argument);
                };
                
                if !is_primitive_color(color) {
                    return Err(ErrorKind::UnknownColor);
                }
                let modified = lex::argument(str)?;

                self.buffer.extend([I::Event(E::Begin(G::Normal)), I::Event(E::StateChange(SC::Color(CC {
                    color,
                    target: CT::Text,
                })))]);
                self.handle_argument(modified)?;
                E::End
            }
            "colorbox" => {
                let Argument::Group(color) =
                    lex::argument(&mut self.content)?
                else {
                    return Err(ErrorKind::Argument);
                };
                if !is_primitive_color(color) {
                    return Err(ErrorKind::UnknownColor);
                }
                self.buffer.extend([I::Event(E::Begin(G::Normal)), I::Event(E::StateChange(SC::Color(CC {
                    color,
                    target: CT::Background,
                })))]);
                self.text_argument()?;
                E::End
            }
            "fcolorbox" => {
                let str = &mut self.content;
                let Argument::Group(frame_color) =
                    lex::argument(str)?
                else {
                    return Err(ErrorKind::Argument);
                };
                let Argument::Group(background_color) =
                    lex::argument(str)?
                else {
                    return Err(ErrorKind::Argument);
                };
                if !is_primitive_color(frame_color) || !is_primitive_color(background_color) {
                    return Err(ErrorKind::UnknownColor);
                }
                self.buffer.extend([I::Event(E::Begin(G::Normal)), I::Event(E::StateChange(SC::Color(CC {
                    color: frame_color,
                    target: CT::Text,
                }))), I::Event(E::StateChange(SC::Color(CC {
                    color: background_color,
                    target: CT::Background,
                })))]);
                self.text_argument()?;
                E::End
            },

            ///////////////////////////////
            // Delimiters size modifiers //
            ///////////////////////////////
            // Sizes taken from `texzilla`
            // Big left and right seem to not care about which delimiter is used. i.e., \bigl) and \bigr) are the same.
            "big" | "bigl" | "bigr" | "bigm" => return self.sized_delim(DelimiterSize::Big),
            "Big" | "Bigl" | "Bigr" | "Bigm" => return self.sized_delim(DelimiterSize::BIG),
            "bigg" | "biggl" | "biggr" | "biggm" => return self.sized_delim(DelimiterSize::Bigg),
            "Bigg" | "Biggl" | "Biggr" | "Biggm" => return self.sized_delim(DelimiterSize::BIGG),

            "left" => {
                let curr_str = &mut self.content;
                let opening = if let Some(rest) = curr_str.strip_prefix('.') {
                    *curr_str = rest;
                    None
                } else {
                    Some(lex::delimiter(curr_str)?.0)
                };

                let curr_str = &mut self.content;
                let group_content = lex::group_content(curr_str, r"\left", r"\right")?;
                let closing = if let Some(rest) = curr_str.strip_prefix('.') {
                    *curr_str = rest;
                    None
                } else {
                    Some(lex::delimiter(curr_str)?.0)
                };

                self.buffer.extend([
                    I::Event(E::Begin(G::LeftRight(opening, closing))),
                    I::SubGroup { content: group_content, allows_alignment: false },
                    I::Event(E::End),
                ]);

                return Ok(());
            }
            // TODO: Check the conditions for this op. Does it need to be
            // within a left-right group?
            "middle" => {
                let delimiter = lex::delimiter(&mut self.content)?;
                E::Content(C::Delimiter {
                    content: delimiter.0,
                    size: Some(DelimiterSize::Big),
                    ty: DelimiterType::Fence,
                })
            }
            "right" => {
                return Err(ErrorKind::UnbalancedGroup(None));
            }

            ///////////////////
            // Big Operators //
            ///////////////////
            // NOTE: All of the following operators allow limit modifiers.
            // The following operators have above and below limits by default.
            "sum" => self.large_op('‚àë', true),
            "prod" => self.large_op('‚àè', true),
            "coprod" => self.large_op('‚àê', true),
            "bigvee" => self.large_op('‚ãÅ', true),
            "bigwedge" => self.large_op('‚ãÄ', true),
            "bigcup" => self.large_op('‚ãÉ', true),
            "bigcap" => self.large_op('‚ãÇ', true),
            "biguplus" => self.large_op('‚®Ñ', true),
            "bigoplus" => self.large_op('‚®Å', true),
            "bigotimes" => self.large_op('‚®Ç', true),
            "bigodot" => self.large_op('‚®Ä', true),
            "bigsqcup" => self.large_op('‚®Ü', true),
            "bigsqcap" => self.large_op('‚®Ö', true),
            "bigtimes" => self.large_op('‚®â', true),
            "intop" => self.large_op('‚à´', true),
            // The following operators do not have above and below limits by default.
            "int" => self.large_op('‚à´', false),
            "iint" => self.large_op('‚à¨', false),
            "iiint" => self.large_op('‚à≠', false),
            "smallint" => {
                self.state.allow_suffix_modifiers = true;
                E::Content(C::LargeOp { content: '‚à´', small: true })
            }
            "iiiint" => self.large_op('‚®å', false),
            "intcap" => self.large_op('‚®ô', false),
            "intcup" => self.large_op('‚®ö', false),
            "oint" => self.large_op('‚àÆ', false),
            "varointclockwise" => self.large_op('‚à≤', false),
            "intclockwise" => self.large_op('‚à±', false),
            "oiint" => self.large_op('‚àØ', false),
            "pointint" => self.large_op('‚®ï', false),
            "rppolint" => self.large_op('‚®í', false),
            "scpolint" => self.large_op('‚®ì', false),
            "oiiint" => self.large_op('‚à∞', false),
            "intlarhk" => self.large_op('‚®ó', false),
            "sqint" => self.large_op('‚®ñ', false),
            "intx" => self.large_op('‚®ò', false),
            "intbar" => self.large_op('‚®ç', false),
            "intBar" => self.large_op('‚®é', false),
            "fint" => self.large_op('‚®è', false),

            /////////////
            // Accents //
            /////////////
            "acute" => return self.accent('¬¥', false),
            "bar" | "overline" => return self.accent('‚Äæ', false),
            "underbar" | "underline" => return self.underscript('_'),
            "breve" => return self.accent('Àò', false),
            "check" => return self.accent('Àá', false),
            "dot" => return self.accent('Àô', false),
            "ddot" => return self.accent('¬®', false),
            "grave" => return self.accent('`', false),
            "hat" => return self.accent('^', false),
            "tilde" => return self.accent('~', false),
            "vec" => return self.accent('‚Üí', false),
            "mathring" => return self.accent('Àö', false),

            // Arrows
            "overleftarrow" => return self.accent('‚Üê', true),
            "underleftarrow" => return self.underscript('‚Üê'),
            "overrightarrow" => return self.accent('‚Üí', true),
            "Overrightarrow" => return self.accent('‚áí', true),
            "underrightarrow" => return self.underscript('‚Üí'),
            "overleftrightarrow" => return self.accent('‚Üî', true),
            "underleftrightarrow" => return self.underscript('‚Üî'),
            "overleftharpoon" => return self.accent('‚Üº', true),
            "overrightharpoon" => return self.accent('‚áÄ', true),

            // Wide ops
            "widecheck" => return self.accent('Àá', true),
            "widehat" => return self.accent('^', true),
            "widetilde" => return self.accent('~', true),
            "wideparen" | "overparen" => return self.accent('‚èú', true),

            // Groups
            "overgroup" => return self.accent('‚è†', true),
            "undergroup" => return self.underscript('‚è°'),
            "overbrace" => return self.accent('‚èû', true),
            "underbrace" => return self.underscript('‚èü'),
            "underparen" => return self.underscript('‚èù'),

            // Primes
            "prime" => ordinary('‚Ä≤'),
            "dprime" => ordinary('‚Ä≥'),
            "trprime" => ordinary('‚Ä¥'),
            "qprime" => ordinary('‚Åó'),
            "backprime" => ordinary('‚Äµ'),
            "backdprime" => ordinary('‚Ä∂'),
            "backtrprime" => ordinary('‚Ä∑'),

            /////////////
            // Spacing //
            /////////////
            "," | "thinspace" => E::Space {
                width: Some((3. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            ">" | ":" | "medspace" => E::Space {
                width: Some((4. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            ";" | "thickspace" => E::Space {
                width: Some((5. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "enspace" => E::Space {
                width: Some((0.5, DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "quad" => E::Space {
                width: Some((1., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "qquad" => E::Space {
                width: Some((2., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "mathstrut" => E::Space {
                width: None,
                height: Some((0.7, DimensionUnit::Em)),
                depth: Some((0.3, DimensionUnit::Em)),
            },
            "~" | "nobreakspace" => E::Content(C::Text("&nbsp;")),
            // Variable spacing
            "kern" => {
                let dimension = lex::dimension(&mut self.content)?;
                E::Space {
                    width: Some(dimension),
                    height: None,
                    depth: None,
                }
            }
            "hskip" => {
                let glue = lex::glue(&mut self.content)?;
                E::Space {
                    width: Some(glue.0),
                    height: None,
                    depth: None,
                }
            }
            "mkern" => {
                let dimension =
                    lex::dimension(&mut self.content)?;
                if dimension.1 == DimensionUnit::Mu {
                    E::Space {
                        width: Some(dimension),
                        height: None,
                        depth: None,
                    }
                } else {
                    return Err(ErrorKind::MathUnit);
                }
            }
            "mskip" => {
                let glue = lex::glue(&mut self.content)?;
                if glue.0.1 == DimensionUnit::Mu
                    && glue.1.map_or(true, |(_, unit)| unit == DimensionUnit::Mu)
                    && glue.2.map_or(true, |(_, unit)| unit == DimensionUnit::Mu) {
                    E::Space {
                        width: Some(glue.0),
                        height: None,
                        depth: None,
                    }
                } else {
                    return Err(ErrorKind::MathUnit);
                }
            }
            "hspace" => {
                let Argument::Group(mut argument) =
                    lex::argument(&mut self.content)?
                else {
                    return Err(ErrorKind::DimensionArgument);
                };
                let glue = lex::glue(&mut argument)?;
                E::Space {
                    width: Some(glue.0),
                    height: None,
                    depth: None,
                }
            }
            // Negative spacing
            "!" | "negthinspace" => E::Space {
                width: Some((-3. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "negmedspace" => E::Space {
                width: Some((-4. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },
            "negthickspace" => E::Space {
                width: Some((-5. / 18., DimensionUnit::Em)),
                height: None,
                depth: None,
            },

            ////////////////////////
            // Logic & Set Theory //
            ////////////////////////
            "forall" => ordinary('‚àÄ'),
            "exists" => ordinary('‚àÉ'),
            "complement" => ordinary('‚àÅ'),
            "nexists" => ordinary('‚àÑ'),
            "neg" | "lnot" => ordinary('¬¨'),
            
            "therefore" => relation('‚à¥'),
            "because" => relation('‚àµ'),
            "subset" => relation('‚äÇ'),
            "supset" => relation('‚äÉ'),
            "strictif" => relation('‚•Ω'),
            "strictfi" => relation('‚•º'),
            "mapsto" => relation('‚Ü¶'),
            "implies" => relation('‚üπ'),
            "mid" => relation('‚à£'),
            "to" => relation('‚Üí'),
            "impliedby" => relation('‚ü∏'),
            "in" | "isin" => relation('‚àà'),
            "ni" => relation('‚àã'),
            "gets" => relation('‚Üê'),
            "iff" => relation('‚ü∫'),
            "notni" => relation('‚àå'),
            
            "land" => binary('‚àß'),
            
            "emptyset" => ordinary('‚àÖ'),
            "varnothing" => ordinary('‚åÄ'),

            //////////////////////
            // Binary Operators //
            //////////////////////
            "ldotp" => binary('.'),
            "cdotp" => binary('¬∑'),
            "cdot" => binary('‚ãÖ'),
            "centerdot" => binary('¬∑'),
            "circ" => binary('‚àò'),
            "bullet" => binary('‚àô'),
            "circledast" => binary('‚äõ'),
            "circledcirc" => binary('‚äö'),
            "circleddash" => binary('‚äù'),
            "bigcirc" => binary('‚óØ'),
            "leftthreetimes" => binary('‚ãã'),
            "rhd" => binary('‚ä≥'),
            "lhd" => binary('‚ä≤'),
            "rightthreetimes" => binary('‚ãå'),
            "rtimes" => binary('‚ãä'),
            "ltimes" => binary('‚ãâ'),
            "leftmodels" => binary('‚ä®'),
            "amalg" => binary('‚®ø'),
            "ast" => binary('*'),
            "asymp" => binary('‚âç'),
            "And" | "with" => binary('&'),
            "lor" => binary('‚à®'),
            "setminus" => binary('‚àñ'),
            "Cup" => binary('‚ãì'),
            "cup" => binary('‚à™'),
            "sqcup" => binary('‚äî'),
            "sqcap" => binary('‚äì'),
            "lessdot" => binary('‚ãñ'),
            "smallsetminus" => E::Content(C::BinaryOp { content: '‚àñ', small: false }),
            "barwedge" => binary('‚åÖ'),
            "curlyvee" => binary('‚ãé'),
            "curlywedge" => binary('‚ãè'),
            "sslash" => binary('‚´Ω'),
            "div" => binary('√∑'),
            "mp" => binary('‚àì'),
            "times" => binary('√ó'),
            "boxdot" => binary('‚ä°'),
            "divideontimes" => binary('‚ãá'),
            "odot" => binary('‚äô'),
            "unlhd" => binary('‚ä¥'),
            "boxminus" => binary('‚äü'),
            "dotplus" => binary('‚àî'),
            "ominus" => binary('‚äñ'),
            "unrhd" => binary('‚äµ'),
            "boxplus" => binary('‚äû'),
            "doublebarwedge" => binary('‚©û'),
            "oplus" => binary('‚äï'),
            "uplus" => binary('‚äé'),
            "boxtimes" => binary('‚ä†'),
            "doublecap" => binary('‚ãí'),
            "otimes" => binary('‚äó'),
            "vee" => binary('‚à®'),
            "veebar" => binary('‚äª'),
            "Cap" => binary('‚ãí'),
            "parr" => binary('‚Öã'),
            "wedge" => binary('‚àß'),
            "cap" => binary('‚à©'),
            "gtrdot" => binary('‚ãó'),
            "pm" => binary('¬±'),
            "intercal" => binary('‚ä∫'),
            "wr" => binary('‚âÄ'),
            "circledvert" => binary('‚¶∂'),
            "blackhourglass" => binary('‚ßó'),
            "circlehbar" => binary('‚¶µ'),
            "operp" => binary('‚¶π'),
            "boxast" => binary('‚ßÜ'),
            "boxbox" => binary('‚ßà'),
            "oslash" => binary('‚äò'),
            "boxcircle" => binary('‚ßá'),
            "diamond" => binary('‚ãÑ'),
            "Otimes" => binary('‚®∑'),
            "hourglass" => binary('‚ßñ'),
            "otimeshat" => binary('‚®∂'),
            "triangletimes" => binary('‚®ª'),
            "lozengeminus" => binary('‚ü†'),
            "star" => binary('‚ãÜ'),
            "obar" => binary('‚åΩ'),
            "obslash" => binary('‚¶∏'),
            "triangleminus" => binary('‚®∫'),
            "odiv" => binary('‚®∏'),
            "triangleplus" => binary('‚®π'),
            "circledequal" => binary('‚äú'),
            "ogreaterthan" => binary('‚ßÅ'),
            "circledparallel" => binary('‚¶∑'),
            "olessthan" => binary('‚ßÄ'),

            ///////////////
            // Relations //
            ///////////////
            "eqcirc" => relation('‚âñ'),
            "lessgtr" => relation('‚â∂'),
            "smile" | "sincoh" => relation('‚å£'),
            "eqcolon" | "minuscolon" => relation('‚àπ'),
            "lesssim" => relation('‚â≤'),
            "sqsubset" => relation('‚äè'),
            "ll" => relation('‚â™'),
            "sqsubseteq" => relation('‚äë'),
            "eqqcolon" => relation('‚âï'),
            "lll" => relation('‚ãò'),
            "sqsupset" => relation('‚äê'),
            "llless" => relation('‚ãò'),
            "sqsupseteq" => relation('‚äí'),
            "approx" => relation('‚âà'),
            "eqdef" => relation('‚âù'),
            "lt" => relation('<'),
            "stareq" => relation('‚âõ'),
            "approxeq" => relation('‚âä'),
            "eqsim" => relation('‚âÇ'),
            "measeq" => relation('‚âû'),
            "Subset" => relation('‚ãê'),
            "arceq" => relation('‚âò'),
            "eqslantgtr" => relation('‚™ñ'),
            "eqslantless" => relation('‚™ï'),
            "models" => relation('‚ä®'),
            "subseteq" => relation('‚äÜ'),
            "backcong" => relation('‚âå'),
            "equiv" => relation('‚â°'),
            "multimap" => relation('‚ä∏'),
            "subseteqq" => relation('‚´Ö'),
            "fallingdotseq" => relation('‚âí'),
            "multimapboth" => relation('‚ßü'),
            "succ" => relation('‚âª'),
            "backsim" => relation('‚àΩ'),
            "frown" => relation('‚å¢'),
            "multimapinv" => relation('‚üú'),
            "succapprox" => relation('‚™∏'),
            "backsimeq" => relation('‚ãç'),
            "ge" => relation('‚â•'),
            "origof" => relation('‚ä∂'),
            "succcurlyeq" => relation('‚âΩ'),
            "between" => relation('‚â¨'),
            "geq" => relation('‚â•'),
            "owns" => relation('‚àã'),
            "succeq" => relation('‚™∞'),
            "bumpeq" => relation('‚âè'),
            "geqq" => relation('‚âß'),
            "parallel" => relation('‚à•'),
            "succsim" => relation('‚âø'),
            "Bumpeq" => relation('‚âé'),
            "geqslant" => relation('‚©æ'),
            "perp" => relation('‚üÇ'),
            "Supset" => relation('‚ãë'),
            "circeq" => relation('‚âó'),
            "gg" => relation('‚â´'),
            "Perp" => relation('‚´´'),
            "coh" => relation('‚å¢'),
            "ggg" => relation('‚ãô'),
            "pitchfork" => relation('‚ãî'),
            "supseteq" => relation('‚äá'),
            "gggtr" => relation('‚ãô'),
            "prec" => relation('‚â∫'),
            "supseteqq" => relation('‚´Ü'),
            "gt" => relation('>'),
            "precapprox" => relation('‚™∑'),
            "thickapprox" => relation('‚âà'),
            "gtrapprox" => relation('‚™Ü'),
            "preccurlyeq" => relation('‚âº'),
            "thicksim" => relation('‚àº'),
            "gtreqless" => relation('‚ãõ'),
            "preceq" => relation('‚™Ø'),
            "trianglelefteq" => relation('‚ä¥'),
            "coloneqq" | "colonequals" => relation('‚âî'),
            "gtreqqless" => relation('‚™å'),
            "precsim" => relation('‚âæ'),
            "triangleq" => relation('‚âú'),
            "Coloneqq" | "coloncolonequals" => relation('‚©¥'),
            "gtrless" => relation('‚â∑'),
            "propto" => relation('‚àù'),
            "trianglerighteq" => relation('‚äµ'),
            "gtrsim" => relation('‚â≥'),
            "questeq" => relation('‚âü'),
            "varpropto" => relation('‚àù'),
            "imageof" => relation('‚ä∑'),
            "cong" => relation('‚âÖ'),
            "risingdotseq" => relation('‚âì'),
            "vartriangleleft" => relation('‚ä≤'),
            "curlyeqprec" => relation('‚ãû'),
            "scoh" => relation('‚å¢'),
            "vartriangleright" => relation('‚ä≥'),
            "curlyeqsucc" => relation('‚ãü'),
            "le" => relation('‚â§'),
            "shortmid" => E::Content(C::Relation { content: '‚à£', unicode_variant: false, small: true }),
            "shortparallel" => E::Content(C::Relation { content: '‚à•', unicode_variant: false, small: true }),
            "vdash" => relation('‚ä¢'),
            "dashv" => relation('‚ä£'),
            "leq" => relation('‚â§'),
            "vDash" => relation('‚ä®'),
            "dblcolon" | "coloncolon" => relation('‚à∑'),
            "leqq" => relation('‚â¶'),
            "sim" => relation('‚àº'),
            "Vdash" => relation('‚ä©'),
            "doteq" => relation('‚âê'),
            "leqslant" => relation('‚©Ω'),
            "simeq" => relation('‚âÉ'),
            "Dash" => relation('‚ä´'),
            "Doteq" => relation('‚âë'),
            "lessapprox" => relation('‚™Ö'),
            "Vvdash" => relation('‚ä™'),
            "doteqdot" => relation('‚âë'),
            "lesseqgtr" => relation('‚ãö'),
            "smallfrown" => relation('‚å¢'),
            "veeeq" => relation('‚âö'),
            "eqeq" => relation('‚©µ'),
            "lesseqqgtr" => relation('‚™ã'),
            "smallsmile" => E::Content(C::Relation { content: '‚å£', unicode_variant: false, small: true }),
            "wedgeq" => relation('‚âô'),
            "bowtie" | "Join" => relation('‚ãà'),
            // Negated relations
            "gnapprox" => relation('‚™ä'),
            "ngeqslant" => relation('‚â±'),
            "nsubset" => relation('‚äÑ'),
            "nVdash" => relation('‚äÆ'),
            "gneq" => relation('‚™à'),
            "ngtr" => relation('‚âØ'),
            "nsubseteq" => relation('‚äà'),
            "precnapprox" => relation('‚™π'),
            "gneqq" => relation('‚â©'),
            "nleq" => relation('‚â∞'),
            "nsubseteqq" => relation('‚äà'),
            "precneqq" => relation('‚™µ'),
            "gnsim" => relation('‚ãß'),
            "nleqq" => relation('‚â∞'),
            "nsucc" => relation('‚äÅ'),
            "precnsim" => relation('‚ã®'),
            "nleqslant" => relation('‚â∞'),
            "nsucceq" => relation('‚ã°'),
            "subsetneq" => relation('‚ää'),
            "lnapprox" => relation('‚™â'),
            "nless" => relation('‚âÆ'),
            "nsupset" => relation('‚äÖ'),
            "subsetneqq" => relation('‚´ã'),
            "lneq" => relation('‚™á'),
            "nmid" => relation('‚à§'),
            "nsupseteq" => relation('‚äâ'),
            "succnapprox" => relation('‚™∫'),
            "lneqq" => relation('‚â®'),
            "notin" => relation('‚àâ'),
            "nsupseteqq" => relation('‚äâ'),
            "succneqq" => relation('‚™∂'),
            "lnsim" => relation('‚ã¶'),
            "ntriangleleft" => relation('‚ã™'),
            "succnsim" => relation('‚ã©'),
            "nparallel" => relation('‚à¶'),
            "ntrianglelefteq" => relation('‚ã¨'),
            "supsetneq" => relation('‚äã'),
            "ncong" => relation('‚âÜ'),
            "nprec" => relation('‚äÄ'),
            "ntriangleright" => relation('‚ã´'),
            "supsetneqq" => relation('‚´å'),
            "ne" => relation('‚â†'),
            "npreceq" => relation('‚ã†'),
            "ntrianglerighteq" => relation('‚ã≠'),
            "neq" => relation('‚â†'),
            "nshortmid" => relation('‚à§'),
            "nvdash" => relation('‚ä¨'),
            "ngeq" => relation('‚â±'),
            "nshortparallel" => E::Content(C::Relation { content: '‚à¶', unicode_variant: false, small: true }),
            "nvDash" => relation('‚ä≠'),
            "ngeqq" => relation('‚â±'),
            "nsim" => relation('‚âÅ'),
            "nVDash" => relation('‚äØ'),
            "varsupsetneqq" => E::Content(C::Relation { content: '‚´å', unicode_variant: true, small: false }),
            "varsubsetneqq" => E::Content(C::Relation { content: '‚´ã', unicode_variant: true, small: false }),
            "varsubsetneq" => E::Content(C::Relation { content: '‚ää', unicode_variant: true, small: false }),
            "varsupsetneq" => E::Content(C::Relation { content: '‚äã', unicode_variant: true, small: false }),
            "gvertneqq" => E::Content(C::Relation { content: '‚â©', unicode_variant: true, small: false }),
            "lvertneqq" => E::Content(C::Relation { content: '‚â®', unicode_variant: true, small: false }),
            "Eqcolon" | "minuscoloncolon" => {
                self.multi_relation([
                    binary('‚àí'),
                    relation('‚à∑'),
                ]);
                return Ok(());
            }
            "Eqqcolon" => {
                self.multi_relation([
                    relation('='),
                    relation('‚à∑'),
                ]);
                return Ok(());
            }
            "approxcolon" => {
                self.multi_relation([
                    relation('‚âà'),
                    relation(':'),
                ]);
                return Ok(());
            }
            "colonapprox" => {
                self.multi_relation([
                    relation(':'),
                    relation('‚âà'),
                ]);
                return Ok(());
            }
            "approxcoloncolon" => {
                self.multi_relation([
                    relation('‚âà'),
                    relation('‚à∑'),
                ]);
                return Ok(());
            }
            "Colonapprox" | "coloncolonapprox" => {
                self.multi_relation([
                    relation('‚à∑'),
                    relation('‚âà'),
                ]);
                return Ok(());
            }
            "coloneq" | "colonminus" => {
                self.multi_relation([
                    relation(':'),
                    binary('‚àí'),
                ]);
                return Ok(());
            }
            "Coloneq" | "coloncolonminus" => {
                self.multi_relation([
                    relation('‚à∑'),
                    binary('‚àí')
                ]);
                return Ok(());
            }
            "colonsim" => {
                self.multi_relation([
                    relation(':'),
                    relation('‚àº'),
                ]);
                return Ok(());
            }
            "Colonsim" | "coloncolonsim" => {
                self.multi_relation([
                    relation('‚à∑'),
                    relation('‚àº'),
                ]);
                return Ok(());
            }

            ////////////
            // Arrows //
            ////////////
            "circlearrowleft" => relation('‚Ü∫'),
            "Leftrightarrow" => relation('‚áî'),
            "restriction" => relation('‚Üæ'),
            "circlearrowright" => relation('‚Üª'),
            "leftrightarrows" => relation('‚áÜ'),
            "rightarrow" => relation('‚Üí'),
            "curvearrowleft" => relation('‚Ü∂'),
            "leftrightharpoons" => relation('‚áã'),
            "Rightarrow" => relation('‚áí'),
            "curvearrowright" => relation('‚Ü∑'),
            "leftrightsquigarrow" => relation('‚Ü≠'),
            "rightarrowtail" => relation('‚Ü£'),
            "dashleftarrow" => relation('‚á†'),
            "Lleftarrow" => relation('‚áö'),
            "rightharpoondown" => relation('‚áÅ'),
            "dashrightarrow" => relation('‚á¢'),
            "longleftarrow" => relation('‚üµ'),
            "rightharpoonup" => relation('‚áÄ'),
            "downarrow" => relation('‚Üì'),
            "Longleftarrow" => relation('‚ü∏'),
            "rightleftarrows" => relation('‚áÑ'),
            "Downarrow" => relation('‚áì'),
            "longleftrightarrow" => relation('‚ü∑'),
            "rightleftharpoons" => relation('‚áå'),
            "downdownarrows" => relation('‚áä'),
            "Longleftrightarrow" => relation('‚ü∫'),
            "rightrightarrows" => relation('‚áâ'),
            "downharpoonleft" => relation('‚áÉ'),
            "longmapsto" => relation('‚üº'),
            "rightsquigarrow" => relation('‚áù'),
            "downharpoonright" => relation('‚áÇ'),
            "longrightarrow" => relation('‚ü∂'),
            "Rrightarrow" => relation('‚áõ'),
            "Longrightarrow" => relation('‚üπ'),
            "Rsh" => relation('‚Ü±'),
            "hookleftarrow" => relation('‚Ü©'),
            "looparrowleft" => relation('‚Ü´'),
            "searrow" => relation('‚Üò'),
            "hookrightarrow" => relation('‚Ü™'),
            "looparrowright" => relation('‚Ü¨'),
            "swarrow" => relation('‚Üô'),
            "Lsh" => relation('‚Ü∞'),
            "mapsfrom" => relation('‚Ü§'),
            "twoheadleftarrow" => relation('‚Üû'),
            "twoheadrightarrow" => relation('‚Ü†'),
            "leadsto" => relation('‚áù'),
            "nearrow" => relation('‚Üó'),
            "uparrow" => relation('‚Üë'),
            "leftarrow" => relation('‚Üê'),
            "nleftarrow" => relation('‚Üö'),
            "Uparrow" => relation('‚áë'),
            "Leftarrow" => relation('‚áê'),
            "nLeftarrow" => relation('‚áç'),
            "updownarrow" => relation('‚Üï'),
            "leftarrowtail" => relation('‚Ü¢'),
            "nleftrightarrow" => relation('‚ÜÆ'),
            "Updownarrow" => relation('‚áï'),
            "leftharpoondown" => relation('‚ÜΩ'),
            "nLeftrightarrow" => relation('‚áé'),
            "upharpoonleft" => relation('‚Üø'),
            "leftharpoonup" => relation('‚Üº'),
            "nrightarrow" => relation('‚Üõ'),
            "upharpoonright" => relation('‚Üæ'),
            "leftleftarrows" => relation('‚áá'),
            "nRightarrow" => relation('‚áè'),
            "upuparrows" => relation('‚áà'),
            "leftrightarrow" => relation('‚Üî'),
            "nwarrow" => relation('‚Üñ'),

            ///////////////
            // Fractions //
            ///////////////
            "frac" => {
                return self.fraction_like(None);
            }
            // TODO: better errors for this
            "genfrac" => {
                let str = &mut self.content;
                let ldelim_argument = lex::argument(str)?;
                let ldelim = match ldelim_argument {
                    Argument::Token(token) => Some(token_to_delim(token).ok_or(ErrorKind::Delimiter)?),
                    Argument::Group(group) => if group.is_empty() {
                        None
                    } else {
                        return Err(ErrorKind::Delimiter);
                    },
                };
                let rdelim_argument = lex::argument(str)?;
                let rdelim = match rdelim_argument {
                    Argument::Token(token) => Some(token_to_delim(token).ok_or(ErrorKind::Delimiter)?),
                    Argument::Group(group) => if group.is_empty() {
                        None
                    } else {
                        return Err(ErrorKind::Delimiter);
                    },
                };
                let bar_size_argument = lex::argument(str)?;
                let bar_size = match bar_size_argument {
                    Argument::Token(_) => return Err(ErrorKind::DimensionArgument),
                    Argument::Group("") => None,
                    Argument::Group(mut group) => lex::dimension(&mut group).and_then(|dim| {
                        if group.is_empty() {
                            Ok(Some(dim))
                        } else {
                            Err(ErrorKind::DimensionArgument)
                        }
                    })?,
                };
                let display_style_argument = lex::argument(str)?;
                let display_style = match display_style_argument {
                    Argument::Token(t) => match t {
                            Token::ControlSequence(_) => return Err(ErrorKind::Argument),
                            Token::Character(c) => Some(match c.into() {
                                '0' => S::Display,
                                '1' => S::Text,
                                '2' => S::Script,
                                '3' => S::ScriptScript,
                                _ => return Err(ErrorKind::Argument),
                            }),
                    },
                    Argument::Group(group) => {
                        match group {
                            "0" => Some(S::Display),
                            "1" => Some(S::Text),
                            "2" => Some(S::Script),
                            "3" => Some(S::ScriptScript),
                            "" => None,
                            _ => return Err(ErrorKind::Argument),
                        }
                    }
                };

                self.buffer.push(I::Event(E::Begin(G::LeftRight(ldelim.map(|c| c.0), rdelim.map(|c| c.0)))));
                if let Some(style) = display_style {
                    self.buffer.push(I::Event(E::StateChange(SC::Style(style))));
                }
                
                self.fraction_like(bar_size)?;
                
                self.buffer.push(I::Event(E::End));
                return Ok(())
            }
            "binom" => {
                self.buffer.push(I::Event(E::Begin(G::LeftRight(Some('('), Some(')')))));
                self.fraction_like(None)?;
                E::End
            }
            "cfrac" => {
                self.buffer.extend([I::Event(E::Begin(G::Internal)),
                                    I::Event(E::StateChange(SC::Style(S::Display)))]);
                self.fraction_like(None)?;
                self.buffer.push(I::Event(E::End));
                return Ok(())
            }
            "tfrac" => {
                self.buffer.extend([I::Event(E::Begin(G::Internal)),
                                    I::Event(E::StateChange(SC::Style(S::Text)))]);
                self.fraction_like(None)?;
                self.buffer.push(I::Event(E::End));
                return Ok(())
            }
            "dfrac" => {
                self.buffer.extend([I::Event(E::Begin(G::Internal)),
                                    I::Event(E::StateChange(SC::Style(S::Script)))]);
                self.fraction_like(None)?;
                self.buffer.push(I::Event(E::End));
                return Ok(())
            }
            "overset" => {
                self.buffer.push(I::Event(E::Script {
                    ty: ST::Superscript,
                    position: SP::AboveBelow,
                }));
                let over = lex::argument(&mut self.content)?;
                self.handle_argument(over)?;
                let base = lex::argument(&mut self.content)?;
                self.handle_argument(base)?;
                return Ok(());
            }
            "underset" => {
                self.buffer.push(I::Event(E::Script {
                    ty: ST::Subscript,
                    position: SP::AboveBelow,
                }));
                let under = lex::argument(&mut self.content)?;
                self.handle_argument(under)?;
                let base = lex::argument(&mut self.content)?;
                self.handle_argument(base)?;
                return Ok(());
            }

            //////////////
            // Radicals //
            //////////////
            "sqrt" => {
                if let Some(index) =
                    lex::optional_argument(&mut self.content)?
                {
                    self.buffer
                        .push(I::Event(E::Visual(V::Root)));
                    let arg = lex::argument(&mut self.content)?;
                    self.handle_argument(arg)?;
                    self.buffer.push(I::SubGroup {
                        content: index,
                        allows_alignment: false,
                    });
                } else {
                    self.buffer
                        .push(I::Event(E::Visual(V::SquareRoot)));
                    let arg = lex::argument(&mut self.content)?;
                    self.handle_argument(arg)?;
                }
                return Ok(());
            }
            "surd" => {
                self.buffer.extend([
                    I::Event(E::Visual(V::SquareRoot)),
                    I::Event(E::Space {
                        width: Some((0., DimensionUnit::Em)),
                        height: Some((0.7, DimensionUnit::Em)),
                        depth: None,
                    }),
                ]);
                return Ok(());
            }

            "backslash" => ordinary('\\'),

            ///////////////////
            // Miscellaneous //
            ///////////////////
            "#" | "%" | "&" | "$" | "_" => ordinary(
                control_sequence
                    .chars()
                    .next()
                    .expect("the control sequence contains one of the matched characters"),
            ),
            "|" => ordinary('‚à•'),
            "text" => return self.text_argument(),
            // TODO: should cancel be its own event?
            "not" | "cancel" => {
                self.buffer
                    .push(I::Event(E::Visual(V::Negation)));
                let argument = lex::argument(&mut self.content)?;
                self.handle_argument(argument)?;
                return Ok(());
            }
            "char" => {
                let number = lex::unsigned_integer(&mut self.content)?;
                if number > 255 {
                    return Err(ErrorKind::InvalidCharNumber);
                }
                E::Content(C::Ordinary {
                    content: char::from_u32(number as u32).expect("the number is a valid char since it is less than 256"),
                    stretchy: false,
                })
            },
            "relax" => {
                return if self.state.invalidate_relax {
                    Err(ErrorKind::Relax)
                } else {
                    Ok(())
                }
            }

            "begingroup" => {
                let group = lex::group_content(&mut self.content, "begingroup", "endgroup")?;
                self.buffer.extend([
                    I::Event(E::Begin(G::Normal)),
                    I::SubGroup { content: group, allows_alignment: false },
                    I::Event(E::End),
                ]);
                return Ok(());
            }
            "endgroup" => return Err(ErrorKind::UnbalancedGroup(None)),

            // TODO: ensure claims that the alignment and newlines event are generated __only__
            // when it is allowed to.
            "begin" => {
                let Argument::Group(argument) = lex::argument(&mut self.content)? else {
                    return Err(ErrorKind::Argument);
                };

                let mut style = None;
                let (environment, wrap) = match argument {
                    "array" =>  {
                        let Argument::Group(array_columns_str) = lex::argument(&mut self.content)? else {
                            return Err(ErrorKind::Argument);
                        };

                        let array_columns = array_columns_str.chars().map(|c| Ok(match c {
                            'c' => AC::Center,
                            'l' => AC::Left,
                            'r' => AC::Right,
                            '|' => AC::VerticalLine,
                            _ => return Err(ErrorKind::Argument), 
                        })).collect::<Result<_, _>>()?;
                        
                        (G::Array(array_columns), None)  
                    },
                    "matrix" => (G::Matrix, None),
                    "smallmatrix" => {
                        style = Some(S::Text);
                        (G::Matrix, None)
                    }
                    "pmatrix" => {
                        (G::Matrix, Some(G::LeftRight(Some('('), Some(')'))))
                    },
                    "bmatrix" => {
                        (G::Matrix, Some(G::LeftRight(Some('['), Some(']'))))
                    },
                    "vmatrix" => {
                        (G::Matrix, Some(G::LeftRight(Some('|'), Some('|'))))
                    },
                    "Vmatrix" => {
                        (G::Matrix, Some(G::LeftRight(Some('‚Äñ'), Some('‚Äñ'))))
                    },
                    "Bmatrix" => {
                        (G::Matrix, Some(G::LeftRight(Some('{'), Some('}'))))
                    },
                    "cases" => (G::Cases, None),
                    "align" => (G::Align, None),
                    _ => return Err(ErrorKind::Environment),
                };

                let wrap_used = if let Some(wrap) = wrap {
                    self.buffer.push(I::Event(E::Begin(wrap)));
                    true
                } else {
                    false
                };
                
                // TODO: correctly spot deeper environment of the same type.
                let content = lex::group_content(
                    &mut self.content,
                    &format!(r"\begin{{{argument}}}"),
                    &format!(r"\end{{{argument}}}")
                )?;
                self.buffer.push(I::Event(E::Begin(environment)));
                if let Some(style) = style {
                    self.buffer.push(I::Event(E::StateChange(SC::Style(style))));
                }
                self.buffer.extend([
                    I::SubGroup { content, allows_alignment: true },
                    I::Event(E::End)
                ]);

                if wrap_used {
                    self.buffer.push(I::Event(E::End));
                }
                return Ok(());
            }
            "end" => return Err(ErrorKind::UnbalancedGroup(None)),
            "\\" | "cr" if self.state.allows_alignment => E::NewLine,

            // Delimiters
            cs if control_sequence_delimiter_map(cs).is_some() => {
                let (content, ty) = control_sequence_delimiter_map(cs).unwrap();
                E::Content(C::Delimiter { content, size: None, ty })
            }

            // Spacing
            c if c.trim_start().is_empty() => E::Content(C::Text("&nbsp;")),

            _ => return Err(ErrorKind::UnknownPrimitive),
        };
        self.buffer.push(I::Event(event));
        Ok(())
    }

    /// Handle a control sequence that outputs more than one event.
    fn multi_relation<const N: usize>(&mut self, events: [E<'a>; N]) {
        self.buffer.push(I::Event(E::Begin(G::Relation)));
        self.buffer
            .extend(events.into_iter().map(I::Event));
        self.buffer.push(I::Event(E::End));
    }

    /// Return a delimiter with the given size from the next character in the parser.
    fn sized_delim(&mut self, size: DelimiterSize) -> InnerResult<()> {
        let current = &mut self.content;
        let (content, ty) = lex::delimiter(current)?;
        self.buffer
            .push(I::Event(E::Content(C::Delimiter { content, size: Some(size), ty })));
        Ok(())
    }

    /// Override the `font_state` for the argument to the command.
    fn font_group(&mut self, font: Option<Font>) -> InnerResult<()> {
        let argument = lex::argument(&mut self.content)?;
        self.buffer.extend([
            I::Event(E::Begin(G::Internal)),
            I::Event(E::StateChange(SC::Font(font))),
        ]);
        match argument {
            Argument::Token(token) => {
                match token {
                    Token::ControlSequence(cs) => self.handle_primitive(cs)?,
                    Token::Character(c) => self.handle_char_token(c)?,
                };
            }
            Argument::Group(group) => {
                self.buffer.push(I::SubGroup { content: group, allows_alignment: false });
            }
        };
        self.buffer.push(I::Event(E::End));
        Ok(())
    }

    /// Accent commands. parse the argument, and overset the accent.
    fn accent(&mut self, accent: char, stretchy: bool) -> InnerResult<()> {
        let argument = lex::argument(&mut self.content)?;
        self.buffer.push(I::Event(E::Script {
            ty: ST::Superscript,
            position: SP::AboveBelow,
        }));
        self.handle_argument(argument)?;
        self.buffer
            .push(I::Event(E::Content(C::Ordinary {
                content: accent,
                stretchy,
            })));
        Ok(())
    }

    /// Underscript commands. parse the argument, and underset the accent.
    fn underscript(&mut self, content: char) -> InnerResult<()> {
        let argument = lex::argument(&mut self.content)?;
        self.buffer.push(I::Event(E::Script {
            ty: ST::Subscript,
            position: SP::AboveBelow,
        }));
        self.handle_argument(argument)?;
        self.buffer
            .push(I::Event(E::Content(C::Ordinary {
                content,
                stretchy: true,
            })));

        Ok(())
    }

    fn large_op(&mut self, op: char, above_below: bool) -> E<'a> {
        self.state.allow_suffix_modifiers = true;
        self.state.above_below_suffix_default = above_below;
        E::Content(C::LargeOp {
            content: op,
            small: false,
        })
    }

    fn font_change(&mut self, font: Font) -> E<'a> {
        self.state.skip_suffixes = true;
        E::StateChange(SC::Font(Some(font)))
    }

    fn style_change(&mut self, style: S) -> E<'a> {
        self.state.skip_suffixes = true;
        E::StateChange(SC::Style(style))
    }

    fn text_argument(&mut self) -> InnerResult<()> {
        let argument = lex::argument(&mut self.content)?;
        self.buffer
            .push(I::Event(E::Content(C::Text(
                match argument {
                    Argument::Token(Token::Character(c)) => c.as_str(),
                    Argument::Group(inner) => inner,
                    _ => return Err(ErrorKind::ControlSequenceAsArgument),
                },
            ))));
        Ok(())
    }

    fn fraction_like(&mut self, bar_size: Option<(f32, DimensionUnit)>) -> InnerResult<()> {
        self.buffer.push(I::Event(E::Visual(V::Fraction(bar_size))));
        let numerator = lex::argument(&mut self.content)?;
        self.handle_argument(numerator)?;
        let denominator = lex::argument(&mut self.content)?;
        self.handle_argument(denominator)?;
        Ok(())
    }
}

#[inline]
fn ordinary(ident: char) -> E<'static> {
    E::Content(C::Ordinary {
        content: ident,
        stretchy: false
    })
}

#[inline]
fn relation(rel: char) -> E<'static> {
    E::Content(C::Relation {
        content: rel,
        unicode_variant: false,
        small: false,
    })
}

#[inline]
fn binary(op: char) -> E<'static> {
    E::Content(C::BinaryOp{ content: op, small: false })
}

// TODO implementations:
// - `raise`, `lower`
// - `hbox`, `mbox`?
// - `vcenter`
// - `rule`
// - `math_` atoms
// - `mathchoice` (TeXbook p. 151)

// Unimplemented primitives:
// `sl` (slanted) font: https://tug.org/texinfohtml/latex2e.html#index-_005csl
// `bbit` (double-struck italic) font
// `symliteral` wtf is this? (in unicode-math)
// `sc` (small caps) font: https://tug.org/texinfohtml/latex2e.html#index-_005csc
